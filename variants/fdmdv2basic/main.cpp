/*********************************************************************
 * Name:          main.cpp
 * Purpose:       Implements simple wxWidgets application with GUI
 *                 created using wxFormBuilder.
 * Author:
 * Created:
 * Copyright:
 * License:       wxWidgets license (www.wxwidgets.org)
 *
 * Notes:        Note that all GUI creation code is implemented in
 *                 gui.cpp source file which is generated by wxFormBuilder.
 *********************************************************************/

#include "main.h"

// initialize the application
IMPLEMENT_APP(MainApp);

////////////////////////////////////////////////////////////////////////////////
// application class implementation
////////////////////////////////////////////////////////////////////////////////

bool MainApp::OnInit()
{
    SetTopWindow( new MainDialog( NULL ) );
    GetTopWindow()->Show();

    // true = enter the main loop
    return true;
}

////////////////////////////////////////////////////////////////////////////////
// main application frame implementation
////////////////////////////////////////////////////////////////////////////////

MainDialog::MainDialog(wxWindow *parent) : MainDialogBase( parent )
{
    m_RxRunning = false;
    m_TxRunning = false;
    if(Pa_Initialize())
    {
        wxMessageBox(wxT("Port Audio failed to initialize"), wxT("Pa_Initialize"), wxOK);
    }
}

MainDialog::~MainDialog()
{
}

void MainDialog::OnInitDialog( wxInitDialogEvent& event )
{
    populateAudioInfo();
}

//-------------------------------------------------------------------------
// populateStandardSampleRates()
//-------------------------------------------------------------------------
void MainDialog::populateStandardSampleRates(
        wxComboBox* target,
        const portaudio::DirectionSpecificStreamParameters &inputParameters,
        const portaudio::DirectionSpecificStreamParameters &outputParameters)
{
    static double STANDARD_SAMPLE_RATES[] = {
                                                8000.0, 9600.0, 11025.0, 12000.0,
                                                16000.0, 22050.0, 24000.0, 32000.0,
                                                44100.0, 48000.0, 88200.0, 96000.0,
                                                -1 // negative terminated list
                                            };
    int printCount = 0;
    wxString tStr;

    for (int i = 0; STANDARD_SAMPLE_RATES[i] > 0; ++i)
    {
        portaudio::StreamParameters tmp = portaudio::StreamParameters(inputParameters, outputParameters, STANDARD_SAMPLE_RATES[i], 0, paNoFlag);
        if (tmp.isSupported())
        {
            tStr.Printf("%i %8.2f", printCount, STANDARD_SAMPLE_RATES[i]);
            target->Append(tStr);
            ++printCount;
        }
    }
    if (printCount == 0)
    {
        tStr = "None\n";
        target->Append(tStr);
    }
}

//-------------------------------------------------------------------------
// OnActivate()
//-------------------------------------------------------------------------
int MainDialog::populateAudioInfo()
{
    wxString tStr;
    wxString ttStr;
    try
    {
        portaudio::AutoSystem autoSys;
        portaudio::System &sys = portaudio::System::instance();
/*

        tStr.Printf("PortAudio version number: %i\n", sys.version());
        m_textTopRight->AppendText(tStr);

        tStr.Printf("PortAudio version number: %s\n", sys.versionText());
        m_textTopRight->AppendText(tStr);

        int numDevices = sys.deviceCount();
        tStr.Printf("Number of devices: %i\n\n", numDevices);
        m_textTopRight->AppendText(tStr);
*/
        for (portaudio::System::DeviceIterator i = sys.devicesBegin(); i != sys.devicesEnd(); ++i)
        {
/*
            tStr.Printf("---------- device #: %i ----------\n", (*i).index());
            m_textTopRight->AppendText(tStr);
            bool defaultDisplayed = false;
            if ((*i).isSystemDefaultInputDevice())
            {
                tStr.Printf("[ System Default Input %s", (*i).hostApi().name());
                m_textTopRight->AppendText(tStr);
                defaultDisplayed = true;
            }
            else if ((*i).isHostApiDefaultInputDevice())
            {
                tStr.Printf("[ HostApi Default %s Input", (*i).hostApi().name());
                m_textTopRight->AppendText(tStr);
                defaultDisplayed = true;
            }
            if ((*i).isSystemDefaultOutputDevice())
            {
                tStr.Printf(defaultDisplayed ? "," : "[");
                m_textTopRight->AppendText(tStr);
                tStr = (" System Default Output");
                m_textTopRight->AppendText(tStr);
                defaultDisplayed = true;
            }
            else if ((*i).isHostApiDefaultOutputDevice())
            {
                tStr.Printf(defaultDisplayed ? "," : "[");
                m_textTopRight->AppendText(tStr);
                tStr.Printf(" HostApi Default %s Output", (*i).hostApi().name());
                m_textTopRight->AppendText(tStr);
                defaultDisplayed = true;
            }
            if (defaultDisplayed)
            {
               tStr  =  " ]\n";
                m_textTopRight->AppendText(tStr);
            }
            ttStr.Printf("Name                        : %s\n", (*i).name());
            tStr  += ttStr;
            ttStr.Printf("Host API                    : %s\n", (*i).hostApi().name());
            tStr  += ttStr;
            ttStr.Printf("Max inputs                  : %i\n", (*i).maxInputChannels());
            tStr  += ttStr;
            ttStr.Printf("Max outputs                 : %i\n\n", (*i).maxOutputChannels());
            tStr  += ttStr;
            ttStr.Printf("Default low input latency   : %8.3f\n", (*i).defaultLowInputLatency());
            tStr  += ttStr;
            ttStr.Printf("Default low output latency  : %8.3f\n", (*i).defaultLowOutputLatency());
            tStr  += ttStr;
            ttStr.Printf("Default high input latency  : %8.3f\n", (*i).defaultHighInputLatency());
            tStr  += ttStr;
            ttStr.Printf("Default high output latency : %8.3f\n\n", (*i).defaultHighOutputLatency());
            tStr  += ttStr;
            m_textTopRight->AppendText(tStr);

#ifdef WIN32_ASIO
            // ASIO specific latency information:
            if ((*i).hostApi().typeId() == paASIO)
            {
                portaudio::AsioDeviceAdapter asioDevice((*i));
                //std::cout << "ASIO minimum buffer size    = " << asioDevice.minBufferSize() << std::endl;
                //std::cout << "ASIO maximum buffer size    = " << asioDevice.maxBufferSize() << std::endl;
                //std::cout << "ASIO preferred buffer size  = " << asioDevice.preferredBufferSize() << std::endl;
                if (asioDevice.granularity() == -1)
                {
                    //std::cout << "ASIO buffer granularity     = power of 2" << std::endl;
                }
                else
                {
                    //std::cout << "ASIO buffer granularity     = " << asioDevice.granularity() << std::endl;
                }
            }
#endif // WIN32_ASIO

            tStr.Printf("Default sample rate         : %8.2f\n", (*i).defaultSampleRate());
            m_textTopRight->AppendText(tStr);
        wxComboBox* m_comboAudioCodec;
        wxComboBox* m_comboCodecTx;
        wxComboBox* m_comboRadioRx;
        wxComboBox* m_comboCodecSpkr;
*/
            // Poll for standard sample rates:
            portaudio::DirectionSpecificStreamParameters inputParameters((*i), (*i).maxInputChannels(), portaudio::INT16, true, 0.0, NULL);
            portaudio::DirectionSpecificStreamParameters outputParameters((*i), (*i).maxOutputChannels(), portaudio::INT16, true, 0.0, NULL);
            if (inputParameters.numChannels() > 0)
            {
//                tStr = "Supported standard Input sample rates\n";
//                m_comboAudioCodec->Append(tStr);
//                tStr.Printf("   for half-duplex 16 bit %i channel input = ", inputParameters.numChannels());
//                m_comboAudioCodec->InsertItems(1, &tStr, 0);
//                m_comboAudioCodec->Append(tStr);
                populateStandardSampleRates(m_comboRxIn, inputParameters, portaudio::DirectionSpecificStreamParameters::null());
            }
            if (outputParameters.numChannels() > 0)
            {
//                tStr = "Supported standard Output sample rates\n";
//                m_comboRadioRx->Append(tStr);
//                tStr.Printf("   for half-duplex 16 bit %i channel output = ", outputParameters.numChannels());
//                m_comboRadioRx->Append(tStr);
                populateStandardSampleRates(m_comboRxOut, portaudio::DirectionSpecificStreamParameters::null(), outputParameters);
            }
            if (inputParameters.numChannels() > 0 && inputParameters.numChannels() > 0)
            {
//                tStr = "Supported full-duplex sample rates\n";
//                m_comboCodecTx->Append(tStr);
//                tStr.Printf("   for full-duplex 16 bit %i channel input, %i", inputParameters.numChannels(), outputParameters.numChannels());
//                m_comboCodecTx->InsertItems(1, &tStr, 0);
//                m_comboCodecTx->Append(tStr);
                populateStandardSampleRates(m_comboTxIn, inputParameters, outputParameters);
            }
            if (outputParameters.numChannels() > 0 && outputParameters.numChannels() > 0)
            {
//                tStr = "Supported full-duplex sample rates\n";
//                m_comboCodecSpkr->Append(tStr);
//                tStr.Printf("   for full-duplex 16 bit %i channel input, %i", inputParameters.numChannels(), outputParameters.numChannels());
//                m_comboCodecTx->InsertItems(1, &tStr, 0);
                populateStandardSampleRates(m_comboTxOut, inputParameters, outputParameters);
            }
        }
    }
    catch (const portaudio::PaException &e)
    {
        tStr.Printf("A PortAudio error occured: %s\n",  e.paErrorText());
        wxMessageBox(tStr, wxT("Portaudio exception"), wxOK);
    }
    catch (const portaudio::PaCppException &e)
    {
        tStr.Printf("A PortAudioCpp error occured: %s\n", e.what());
        wxMessageBox(tStr, wxT("PortAudioCpp error"), wxOK);
    }
    catch (const std::exception &e)
    {
        tStr.Printf("A generic exception occured: %s\n", e.what());
        wxMessageBox(tStr, wxT("Generic Exception"), wxOK);
    }
    catch (...)
    {
        tStr.Printf("An unknown exception occured.\n");
        wxMessageBox(tStr, wxT("Unknown error"), wxOK);
    }
    return 0;
}

void MainDialog::OnToggleStartStop( wxCommandEvent& event )
{
    if((!m_TxRunning) || (!m_RxRunning))
    {
        startRxStream();
        startTxStream();
    }
    else
    {
        stopRxStream();
        stopTxStream();
    }
}

void MainDialog::OnToggleRxRx( wxCommandEvent& event )
{
}

void MainDialog::OnRxInSelect(wxCommandEvent& event)
{
}

void MainDialog::OnRxOutSelect(wxCommandEvent& event)
{
}

void MainDialog::OnTxInSelect(wxCommandEvent& event)
{
}

void MainDialog::OnTxOutSelect(wxCommandEvent& event)
{
}

void MainDialog::OnRadioSelect(wxCommandEvent& event)
{
}

void MainDialog::OnPortSelect(wxCommandEvent& event)
{
}

void MainDialog::OnCloseDialog(wxCloseEvent& event)
{
    Pa_Terminate();
    Destroy();
}

void MainDialog::OnOKClick(wxCommandEvent& event)
{
    Pa_Terminate();
    Destroy();
}

void MainDialog::OnCancelClick(wxCommandEvent& event)
{
    Pa_Terminate();
    Destroy();
}

//-------------------------------------------------------------------------
// rxCallback()
//-------------------------------------------------------------------------
static int rxCallback(   const void *inBuffer,
                            void *outBuffer,
                            unsigned long framesPerBuffer,
                            const PaStreamCallbackTimeInfo *outTime,
                            PaStreamCallbackFlags statusFlags,
                            void *userData
                        )
{
    float *out = (float *) outBuffer;
    float *in  = (float *) inBuffer;
    float leftIn;
    float rightIn;
    unsigned int i;

    if(inBuffer == NULL)
    {
        return 0;
    }
    // Read input buffer, process data, and fill output buffer.
    for(i = 0; i < framesPerBuffer; i++)
    {
        leftIn  = *in++;                            // Get interleaved samples from input buffer.
        rightIn = *in++;
        *out++  = leftIn * rightIn;                 // ring modulation
        *out++  = 0.5f * (leftIn + rightIn);        // mixing
    }
    return paContinue;                              // 0;
}

//-------------------------------------------------------------------------
// txCallback()
//-------------------------------------------------------------------------
static int txCallback(   const void *inBuffer,
                            void *outBuffer,
                            unsigned long framesPerBuffer,
                            const PaStreamCallbackTimeInfo *outTime,
                            PaStreamCallbackFlags statusFlags,
                            void *userData
                        )
{
    float *out = (float *) outBuffer;
    float *in  = (float *) inBuffer;
    float leftIn;
    float rightIn;
    unsigned int i;

    if(inBuffer == NULL)
    {
        return 0;
    }
    // Read input buffer, process data, and fill output buffer.
    for(i = 0; i < framesPerBuffer; i++)
    {
        leftIn  = *in++;                            // Get interleaved samples from input buffer.
        rightIn = *in++;
        *out++  = leftIn * rightIn;                 // ring modulation
        *out++  = 0.5f * (leftIn + rightIn);        // mixing
    }
    return paContinue;                              // 0;
}

//-------------------------------------------------------------------------
// startRxStream()
//-------------------------------------------------------------------------
void MainDialog::startRxStream()
{
    if(!m_RxRunning)
    {
        m_RxRunning = true;
        m_rxPa = new PortAudioWrap();

        m_rxDevIn = m_rxPa->getDefaultInputDevice();                   // default input device
        if(m_rxDevIn == paNoDevice)
        {
            wxMessageBox(wxT("Rx Error: No default input device."), wxT("Error"), wxOK);
            return;
        }
        m_rxErr = m_rxPa->setInputDevice(m_rxDevIn);
        m_rxErr = m_rxPa->setInputChannelCount(2);                           // stereo input
        m_rxErr = m_rxPa->setInputSampleFormat(PA_SAMPLE_TYPE);
        m_rxErr = m_rxPa->setInputLatency(m_rxPa->getInputDefaultLowLatency());
        m_rxPa->setInputHostApiStreamInfo(NULL);

        m_rxDevOut = m_rxPa->getDefaultOutputDevice();                 // default output device
        if (m_rxDevOut == paNoDevice)
        {
            wxMessageBox(wxT("Rx Error: No default output device."), wxT("Error"), wxOK);
            return;
        }
        m_rxErr = m_rxPa->setOutputDevice(m_rxDevOut);
        m_rxErr = m_rxPa->setOutputChannelCount(2);                           // stereo input
        m_rxErr = m_rxPa->setOutputSampleFormat(PA_SAMPLE_TYPE);

        m_rxErr = m_rxPa->setOutputLatency(m_rxPa->getOutputDefaultLowLatency());
        m_rxPa->setOutputHostApiStreamInfo(NULL);

        m_rxErr = m_rxPa->setFramesPerBuffer(FRAMES_PER_BUFFER);
        m_rxErr = m_rxPa->setSampleRate(SAMPLE_RATE);
        m_rxErr = m_rxPa->setStreamFlags(0);
        m_rxErr = m_rxPa->setCallback(rxCallback);
        m_rxErr = m_rxPa->streamOpen();

        if(m_rxErr != paNoError)
        {
            wxMessageBox(wxT("Rx Stream Open/Setup error."), wxT("Error"), wxOK);
            return;
        }
        m_rxErr = m_rxPa->streamStart();
        if(m_rxErr != paNoError)
        {
            wxMessageBox(wxT("Rx Stream Start Error."), wxT("Error"), wxOK);
            return;
        }
        m_toggleStartStop->SetLabel(wxT("Stop"));
    }
}

//-------------------------------------------------------------------------
// stopRxStream()
//-------------------------------------------------------------------------
void MainDialog::stopRxStream()
{
    if(m_RxRunning)
    {
        m_RxRunning = false;
        m_rxPa->stop();
        m_rxPa->streamClose();
        m_toggleStartStop->SetLabel(wxT("Start"));
    }
}

//-------------------------------------------------------------------------
// abortRxStream()
//-------------------------------------------------------------------------
void MainDialog::abortRxStream()
{
    if(m_RxRunning)
    {
        m_RxRunning = false;
        m_rxPa->abort();
        m_toggleStartStop->SetLabel(wxT("Start"));
    }
}

//-------------------------------------------------------------------------
// startTxStream()
//-------------------------------------------------------------------------
void MainDialog::startTxStream()
{
    if(!m_TxRunning)
    {
        m_TxRunning = true;
        m_txPa = new PortAudioWrap();

        m_txDevIn = m_txPa->getDefaultInputDevice();                   // default input device
        if(m_txDevIn == paNoDevice)
        {
            wxMessageBox(wxT("Tx Error: No default input device."), wxT("Error"), wxOK);
            return;
        }
        m_txErr = m_txPa->setInputDevice(m_txDevIn);
        m_txErr = m_txPa->setInputChannelCount(2);                           // stereo input
        m_txErr = m_txPa->setInputSampleFormat(PA_SAMPLE_TYPE);
        m_txErr = m_txPa->setInputLatency(m_txPa->getInputDefaultLowLatency());
        m_txPa->setInputHostApiStreamInfo(NULL);

        m_txDevOut = m_txPa->getDefaultOutputDevice();                 // default output device
        if (m_txDevOut == paNoDevice)
        {
            wxMessageBox(wxT("Tx Error: No default output device."), wxT("Error"), wxOK);
            return;
        }
        m_txErr = m_txPa->setOutputDevice(m_txDevOut);
        m_txErr = m_txPa->setOutputChannelCount(2);                           // stereo input
        m_txErr = m_txPa->setOutputSampleFormat(PA_SAMPLE_TYPE);

        m_txErr = m_txPa->setOutputLatency(m_txPa->getOutputDefaultLowLatency());
        m_txPa->setOutputHostApiStreamInfo(NULL);

        m_txErr = m_txPa->setFramesPerBuffer(FRAMES_PER_BUFFER);
        m_txErr = m_txPa->setSampleRate(SAMPLE_RATE);
        m_txErr = m_txPa->setStreamFlags(0);
        m_txErr = m_txPa->setCallback(txCallback);
        m_txErr = m_txPa->streamOpen();

        if(m_txErr != paNoError)
        {
            wxMessageBox(wxT("Tx Stream Open/Setup error."), wxT("Error"), wxOK);
            return;
        }
        m_txErr = m_txPa->streamStart();
        if(m_txErr != paNoError)
        {
            wxMessageBox(wxT("Tx Stream Start Error."), wxT("Error"), wxOK);
            return;
        }
        m_toggleStartStop->SetLabel(wxT("Stop"));
    }
}

//-------------------------------------------------------------------------
// stopTxStream()
//-------------------------------------------------------------------------
void MainDialog::stopTxStream()
{
    if(m_TxRunning)
    {
        m_TxRunning = false;
        m_txPa->stop();
        m_txPa->streamClose();
        m_toggleStartStop->SetLabel(wxT("Start"));
    }
}

//-------------------------------------------------------------------------
// abortTxStream()
//-------------------------------------------------------------------------
void MainDialog::abortTxStream()
{
    if(m_TxRunning)
    {
        m_TxRunning = false;
        m_txPa->abort();
        m_toggleStartStop->SetLabel(wxT("Start"));
    }
}
