/*********************************************************************
 * Name:          main.cpp
 * Purpose:       Implements simple wxWidgets application with GUI
 *                 created using wxFormBuilder.
 * Author:
 * Created:
 * Copyright:
 * License:       wxWidgets license (www.wxwidgets.org)
 *
 * Notes:        Note that all GUI creation code is implemented in
 *                 gui.cpp source file which is generated by wxFormBuilder.
 *********************************************************************/

#include "main.h"

// initialize the application
IMPLEMENT_APP(MainApp);

////////////////////////////////////////////////////////////////////////////////
// application class implementation
////////////////////////////////////////////////////////////////////////////////

bool MainApp::OnInit()
{
    SetTopWindow(new MainFrame(NULL));
    GetTopWindow()->Show();

    // true = enter the main loop
    return true;
}

////////////////////////////////////////////////////////////////////////////////
// main application frame implementation
////////////////////////////////////////////////////////////////////////////////

MainFrame::MainFrame(wxWindow *parent) : MainFrameBase(parent)
{
}

MainFrame::~MainFrame()
{
}

void MainFrame::OnCloseFrame(wxCloseEvent& event)
{
    Destroy();
}

void MainFrame::OnExitClick(wxCommandEvent& event)
{
    Destroy();
}

void MainFrame::OnComboLeft( wxCommandEvent& event )
{
    event.Skip();
}

void MainFrame::OnComboRight( wxCommandEvent& event )
{
    event.Skip();
}

void MainFrame::OnScroll( wxScrollEvent& event )
{
    event.Skip();
}

void MainFrame::OnBtnLeft( wxCommandEvent& event )
{
    populateAudioInfo();
    event.Skip();
}

void MainFrame::OnBtnRight( wxCommandEvent& event )
{
    event.Skip();
}

void MainFrame::populateStandardSampleRates(
        wxListBox* target,
        const portaudio::DirectionSpecificStreamParameters &inputParameters,
        const portaudio::DirectionSpecificStreamParameters &outputParameters)
{
    static double STANDARD_SAMPLE_RATES[] = {
                                                8000.0,
                                                9600.0,
                                                11025.0,
                                                12000.0,
                                                16000.0,
                                                22050.0,
                                                24000.0,
                                                32000.0,
                                                44100.0,
                                                48000.0,
                                                88200.0,
                                                96000.0,
                                                192000.0,
                                                -1
                                            }; // negative terminated list

    int printCount = 0;
    wxString tStr;

    for (int i = 0; STANDARD_SAMPLE_RATES[i] > 0; ++i)
    {
        portaudio::StreamParameters tmp = portaudio::StreamParameters(inputParameters, outputParameters, STANDARD_SAMPLE_RATES[i], 0, paNoFlag);
        if (tmp.isSupported())
        {
            tStr.Printf("%8.2f", STANDARD_SAMPLE_RATES[i]);
            if (printCount == 0)
            {
                target->InsertItems(1, &tStr, 0);
                printCount = 1;
            }
            else if (printCount == 4)
            {
                target->InsertItems(1, &tStr, 0);
                printCount = 1;
            }
            else
            {
                target->InsertItems(1, &tStr, 0);
                 ++printCount;
            }
        }
    }
    if (printCount == 0)
    {
        //std::cout << "None" << std::endl;
        tStr = "None\n";
        target->InsertItems(1, &tStr, 0);
    }

/*
   else
    {
        std::cout << std::endl;
    }
*/
}

int MainFrame::populateAudioInfo()
{
    wxString tStr;
    wxString ttStr;
    try
    {
        portaudio::AutoSystem autoSys;
        portaudio::System &sys = portaudio::System::instance();

        tStr.Printf("PortAudio version number: %i\n", sys.version());
        m_textTopRight->AppendText(tStr);

        tStr.Printf("PortAudio version number: %s\n", sys.versionText());
        m_textTopRight->AppendText(tStr);

        int numDevices = sys.deviceCount();
        tStr.Printf("Number of devices: %i\n\n", numDevices);
        m_textTopRight->AppendText(tStr);

        for (portaudio::System::DeviceIterator i = sys.devicesBegin(); i != sys.devicesEnd(); ++i)
        {
            tStr.Printf("---------- device #: %i ----------\n", (*i).index());
            m_textTopRight->AppendText(tStr);

            bool defaultDisplayed = false;

            if ((*i).isSystemDefaultInputDevice())
            {
                tStr.Printf("[ System Default Input %s", (*i).hostApi().name());
                m_textTopRight->AppendText(tStr);
                defaultDisplayed = true;
            }
            else if ((*i).isHostApiDefaultInputDevice())
            {
                tStr.Printf("[ HostApi Default %s Input", (*i).hostApi().name());
                m_textTopRight->AppendText(tStr);
                defaultDisplayed = true;
            }
            if ((*i).isSystemDefaultOutputDevice())
            {
                tStr.Printf(defaultDisplayed ? "," : "[");
                m_textTopRight->AppendText(tStr);
                tStr = (" System Default Output");
                m_textTopRight->AppendText(tStr);
                defaultDisplayed = true;
            }
            else if ((*i).isHostApiDefaultOutputDevice())
            {
                tStr.Printf(defaultDisplayed ? "," : "[");
                m_textTopRight->AppendText(tStr);
                tStr.Printf(" HostApi Default %s Output", (*i).hostApi().name());
                m_textTopRight->AppendText(tStr);
                defaultDisplayed = true;
            }

            if (defaultDisplayed)
            {
               tStr  =  " ]\n";
                m_textTopRight->AppendText(tStr);
            }

            ttStr.Printf("Name                        : %s\n", (*i).name());
            tStr  += ttStr;
            ttStr.Printf("Host API                    : %s\n", (*i).hostApi().name());
            tStr  += ttStr;
            ttStr.Printf("Max inputs                  : %i\n", (*i).maxInputChannels());
            tStr  += ttStr;
            ttStr.Printf("Max outputs                 : %i\n\n", (*i).maxOutputChannels());
            tStr  += ttStr;

            ttStr.Printf("Default low input latency   : %8.3f\n", (*i).defaultLowInputLatency());
            tStr  += ttStr;
            ttStr.Printf("Default low output latency  : %8.3f\n", (*i).defaultLowOutputLatency());
            tStr  += ttStr;
            ttStr.Printf("Default high input latency  : %8.3f\n", (*i).defaultHighInputLatency());
            tStr  += ttStr;
            ttStr.Printf("Default high output latency : %8.3f\n\n", (*i).defaultHighOutputLatency());
            tStr  += ttStr;
            m_textTopRight->AppendText(tStr);

#ifdef WIN32_ASIO
            // ASIO specific latency information:
            if ((*i).hostApi().typeId() == paASIO)
            {
                portaudio::AsioDeviceAdapter asioDevice((*i));

                //std::cout << "ASIO minimum buffer size    = " << asioDevice.minBufferSize() << std::endl;
                //std::cout << "ASIO maximum buffer size    = " << asioDevice.maxBufferSize() << std::endl;
                //std::cout << "ASIO preferred buffer size  = " << asioDevice.preferredBufferSize() << std::endl;

                if (asioDevice.granularity() == -1)
                {
                    //std::cout << "ASIO buffer granularity     = power of 2" << std::endl;
                }
                else
                {
                    //std::cout << "ASIO buffer granularity     = " << asioDevice.granularity() << std::endl;
                }
            }
#endif // WIN32_ASIO

            tStr.Printf("Default sample rate         : %8.2f\n", (*i).defaultSampleRate());
            m_textTopRight->AppendText(tStr);

            // Poll for standard sample rates:
            portaudio::DirectionSpecificStreamParameters inputParameters((*i), (*i).maxInputChannels(), portaudio::INT16, true, 0.0, NULL);
            portaudio::DirectionSpecificStreamParameters outputParameters((*i), (*i).maxOutputChannels(), portaudio::INT16, true, 0.0, NULL);
            if (inputParameters.numChannels() > 0)
            {
                tStr = "Supported standard Input sample rates\n";
                m_listBoxTopLeft->InsertItems(1, &tStr, 0);
                tStr.Printf("   for half-duplex 16 bit %i channel input = ", inputParameters.numChannels());
                m_listBoxTopLeft->InsertItems(1, &tStr, 0);
                populateStandardSampleRates(m_listBoxTopLeft, inputParameters, portaudio::DirectionSpecificStreamParameters::null());
            }
            if (outputParameters.numChannels() > 0)
            {
                tStr = "Supported standard Output sample rates\n";
                m_listBoxMidLeft->InsertItems(1, &tStr, 0);
                tStr.Printf("   for half-duplex 16 bit %i channel output = ", outputParameters.numChannels());
                m_listBoxMidLeft->InsertItems(1, &tStr, 0);
                populateStandardSampleRates(m_listBoxMidLeft, portaudio::DirectionSpecificStreamParameters::null(), outputParameters);
            }
            if (inputParameters.numChannels() > 0 && outputParameters.numChannels() > 0)
            {
                tStr = "Supported full-duplex sample rates\n";
                m_listBoxMidRight->InsertItems(1, &tStr, 0);
                tStr.Printf("   for full-duplex 16 bit %i channel input, %i", inputParameters.numChannels(), outputParameters.numChannels());
                m_listBoxMidRight->InsertItems(1, &tStr, 0);
                populateStandardSampleRates(m_listBoxMidRight, inputParameters, outputParameters);
            }
            tStr.Printf("---------------------------------\n");
            m_textTopRight->AppendText(tStr);
        }
    }
    catch (const portaudio::PaException &e)
    {
        tStr.Printf("A PortAudio error occured: %s\n",  e.paErrorText());
        m_textTopRight->AppendText(tStr);
    }
    catch (const portaudio::PaCppException &e)
    {
        tStr.Printf("A PortAudioCpp error occured: %s\n", e.what());
        m_textTopRight->AppendText(tStr);
    }
    catch (const std::exception &e)
    {
        tStr.Printf("A generic exception occured: %s\n", e.what());
        m_textTopRight->AppendText(tStr);
    }
    catch (...)
    {
        tStr.Printf("An unknown exception occured.\n");
        m_textTopRight->AppendText(tStr);
    }
    return 0;
}


